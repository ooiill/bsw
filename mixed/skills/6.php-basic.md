
# PHP 基础能力

### error_reporting (2047)

| 操作符 | 含义 |
| :---: | :---: |
| `|` | 加法 |
| `^` | 减法 |
| `& ~` | 减法 |

> `E_ERROR` | `E_WARNING` | `E_PARSE` | `E_NOTICE` |   
> `E_CORE_ERROR` | `E_CORE_WARNING` |   
> `E_COMPILE_ERROR` | `E_COMPILE_WARNING` |  
> `E_USER_ERROR` | `E_USER_WARNING` | `E_USER_NOTICE`   
  
| 值 | 常量 | 描述 |
| --- | --- | --- |
| `1` | `E_ERROR` | 运行时致命错误 |
| `2` | `E_WARNING` | 运行时警告 |
| `4` | `E_PARSE` | 编译时语法解析错误 |
| `8` | `E_NOTICE` | 运行时通知     |
| `16` | `E_CORE_ERROR` | `PHP` 初始化启动过程中发生的致命错误 |
| `32` | `E_CORE_WARNING` | `PHP` 初始化启动过程中发生的警告 |
| `64` | `E_COMPILE_ERROR` | 编译时致命错误 |
| `128` | `E_COMPILE_WARNING` | 编译时警告 |
| `256` | `E_USER_ERROR` | 用户产生的错误信息 |
| `512` | `E_USER_WARNING` | 用户产生的警告信息 |
| `1024` | `E_USER_NOTICE` | 用户产生的通知信息 |
| `2048` | `E_STRICT` | 启用 `PHP` 对代码的修改建议 |
| `4096` | `E_RECOVERABLE_ERROR` | 可被捕捉的致命错误 |
| `8192` | `E_DEPRECATED` | 运行时通知 |
| `16384` | `E_USER_DEPRECATED` | 用户产生的警告信息 |
| `30719` | `E_ALL` | 除了 `E_STRICT` 外的所有错误和警告信息 |
  
### 排序函数  
    
| 方法 | 描述 |
| ---: | --- |
| `sort` | `value` 升序排序但删除索引重新从 `0` 开始建立索引 |
| `rsort` | `value` 倒序排序，其他与 `sort` 一致  |
| `asort` | `value` 升序排序并保留索引 |
| `arsort` | `value` 倒序排序，其他与 `asort` 一致 |
| `ksort` | `key` 升序排序并保留索引 |
| `krsort` | `key` 倒序排序，其他与 `ksort` 一致 |
| `natsort` | 用自然排序算法对数组排序 |
| `natcasesort` | 用自然排序算法对数组进行不区分大小写字母的排序 |
| `shuffle` | 随机排序打乱数组 |
  
### 不用变量交换现有两个变量

```php
list($a, $b) = [$b, $a];  

// 数组和字符通用
$a = 'a';
$b = 'b';
$a = $a ^ $b;
$b = $b ^ $a;
$a = $a ^ $b;

// 只适用于数字
$a = 3;
$b = 5;
$a = $a + $b;
$b = $a - $b;
$a = $a - $b;
```

### 位运算  

| 例子 | 操作符 | 描述 | 详情 |
| --- | --- | --- | --- |
| `$a` & `$b` | `And` | 按位与 | 将把 `$a` 和 `$b` 中都为 `1` 的位设为 `1` |
| `$a` &#124; `$b` | `Or` | 按位或 | 将把 `$a` 和 `$b` 中任何一个为 `1` 的位设为 `1` |
| `$a` ^ `$b` | `Xor` | 按位异或 | 将把 `$a` 和 `$b` 中一个为 `1` 另一个为 `0` 的位设为 `1` |
| ~ `$a` | `Not` | 按位取反 | 将 `$a` 中为 `0` 的位设为 `1` ，反之亦然 |
| `$a` << `$b`  | `Shift left` | 左移 | 将 `$a` 中的位向左移动 `$b` 次 (每一次移动都表示 `乘以 2`) |
| `$a` >> `$b` | `Shift right` | 右移 | 将 `$a` 中的位向右移动 `$b` 次 (每一次移动都表示 `除以 2`) |

> 位移在 `PHP` 中是数学运算。  
> 向任何方向移出去的位都被丢弃。  
> 左移时右侧以零填充，符号位被移走意味着正号不被保留。  
> 右移时左侧以符号位填充，意味着正负号被保留 (有符号二进制左侧位 `1` 表示负数，`0` 表示正数)。  

### PHP 函数引用

> `PHP` 的引用 (就是在变量或者函数、对象等前面加上 `&` 符号)。
> 删除引用的变量 ，只是引用的变量访问不了，但是内容并没有销毁。  
> 在 `PHP` 中引用的意思是：不同的名字访问同一个变量内容。

```php
function &test(){ 
    static $b = 0; // 申明一个静态变量 
    $b = $b + 1; 
    echo $b; 
    
    return $b;
}

$a = test();  // 这条语句会输出 $b 的值为１ 

$a = 5;
$a = test();  // 这条语句会输出 $b 的值为 2

$a = &test(); // 这条语句会输出 $b 的值为 3 

$a = 5;
$a = test();  // 这条语句会输出 $b 的值为 6
```

### PHP 大小写区分

#### **大小写敏感** 

* 变量名区分大小写；

* 常量名区分大小写，通常都写为大写； 

#### **大小写不敏感** 

* 函数名；  

* 方法名；  

* 类名；  

* 魔术常量不区分大小写，推荐大写；

* `NULL`、`TRUE`、`FALSE` 不区分大小写； 

### PHP 抽象类和接口  
  
* 接口  
  
    * 对接口的使用是通过关键字 `implements` ，可以实现多个接口用逗号分隔。
    
    * 接口不能定义成员变量 (包括类静态变量)，能定义常量。
    
    * 接口只能定义不能实现该方法。  
    
    * 子类必须实现接口定义的所有方法。  
    
    * 接口可以有构造函数。  
    
    * 接口中的方法只能使用 `public` 来修饰。
  
* 抽象类  
  
    * 对抽象类的使用是通过关键字 `extends`，只能继承一个抽象类。
    
    * 不能被实例化。  
    
    * 子类必须定义父类中的所有抽象方法，这些方法的访问控制必须和父类中一样 (或者更为宽松)。
    
    * 如一个类中有一个抽象方法，则该类必须定义为抽象类。  
    
    * 抽象类可以有构造函数。  
    
    * 抽象类中的方法可以使用 `private`、`protected`、`public` 来修饰。  
  
* `final` 类/方法
  
    * `final` 类不能被继承。  
    
    * `final` 方法不能被重写。  
    
    * 属性不能使用 `final` 修饰。
  
* `static` 类/方法
  
        class Say {
            static author = 'Leon';
            public static function hello($word)
            {
                echo self::$author . ' say: ' . $word;
            }
        }
  
* 访问静态方法

        # Way 1
        Say::hello('world');

        # Way 2
        $obj = new Say();
        $obj->helo('world');

* 访问静态属性

        echo Say::$author;

### Session 和 Cookie 的联系与区别

两者区别：

1. `cookie` 数据存放在客户的浏览器上，`session` 数据放在服务器上。

2. `cookie` 不是很安全，别人可以盗取存放在本地的 `cookie` 从而进行 `cookie` 欺骗，如常见的 `xss` 和 `csrf` 攻击，考虑到安全应当使用 `session`。

3. `session` 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 `cookie`。

4. 单个 `cookie` 保存的数据不能超过 `4K`，很多浏览器都限制一个站点最多保存 `20` 个 `cookie`。

两者联系：

项目页面首次被访问的时候会自动生成一个 `session id`，这个值会被存储在 `key` 等于 `PHPSESSID` 的 `cookie` 中，浏览器每次访问服务器的时候都会携带这个 `id`，服务器拿到这个 `id` 后会到 `session` 目录中寻找对应的 `session` 文件。所以 `session` 是依赖于 `cookie` 的，如果客户端禁用 `cookie`，理论上 `session` 也会失效，但你也可以通过 `url` 方式传递 `session id` 来达到 `session` 功能的延续。
